<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="drawLegend.js"></script>
</head>

<body>
  <div>
    <svg id="network" width="900" height="800"></svg>
    <svg id="legend" width="500" height="50"></svg>
    <div class="range">
      <input type="text" id="minAsset" name="minAsset" placeholder="Min Asset">
      <input type="text" id="maxAsset" name="maxAsset" placeholder="Max Asset">
    </div>
    <button id="button">button</button>
  </div>

</body>

<script>
  const svg = d3.select("svg#network");
  const height = svg.attr("height");
  const width = svg.attr("width");

  let chartArea = svg.append("g");

  const requestData = async () => {
    const data = await d3.csv("datasets/bfb-data.csv", d3.autoType);
    const dataFilter0 = await d3.json("datasets/total.json", d3.autoType);

    data.forEach(d => {
      // convert a currency string to a double 
      d["Asset"] = parseFloat(d["Approx. Asset (Millions)"].replace(/[$,]+/g, ""));
      d["Deposit"] = parseFloat(d["Approx. Deposit (Millions)"].replace(/[$,]+/g, ""));

      // split bank name, city, and state 
      const arr = d["Bank Name, City, State"].split(', ');
      d["Bank"] = arr[0];
      d["City"] = arr[1];
      d["State"] = arr[2];
    });

    // sort data by descending Asset
    function compare(a, b) {
      if (a.Asset > b.Asset) {
        return -1;
      }
      if (a.Asset < b.Asset) {
        return 1;
      }
      return 0;
    }
    data.sort(compare);
    console.log("data after processing", data);

    // External code for wrapping a text in d3
    // Citation: https://stackoverflow.com/questions/24784302/wrapping-text-in-d3 
    function wrap(text, width) {
      text.each(function () {
        var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          x = text.attr("x"),
          y = text.attr("y"),
          dy = 0, //parseFloat(text.attr("dy")),
          tspan = text.text(null)
            .append("tspan")
            .attr("x", x)
            .attr("y", y)
            .attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan")
              .attr("x", x)
              .attr("y", y)
              .attr("dy", ++lineNumber * lineHeight + dy + "em")
              .text(word);
          }
        }
      });
    }

    function drawNetworkDiagram(data) {
      let assetExtent = d3.extent(data, d => d['Asset']);
      let assetScale = d3.scaleSqrt().domain(assetExtent).range([3, 130]);
      const colorScale = d3.scaleLog().domain(assetExtent).interpolate(d => d3.interpolateYlGn);

      // Instructor provided code
      // Citation: https://github.com/jeffrz/info3300-fa2022/blob/main/notes/22.10.03.notes.htm
      drawLegend("svg#legend", colorScale);

      // initial drawing for zoom
      // let circles = chartArea.selectAll("circle.node")
      //   .data(data)
      //   .join(
      //     enter => enter.append("circle")
      //       .attr("class", "node")
      //       .attr("r", d => assetScale(d['Asset']))
      //       .attr("cx", d => d.x)
      //       .attr("cy", d => d.y)
      //       .attr("fill", d => colorScale(d['Asset']))
      //     // .call(d3.drag().on("start", dragstart)
      //     //   .on("drag", dragging)
      //     //   .on("end", dragend))
      //   )
      //   .transition()
      //   .duration(1250)
      //   .attr('opacity', 1)
      // var k = 1;
      // //zooming
      // var zoom = d3.zoom().scaleExtent([1, 10]).on("zoom", zoomed)
      // svg.call(zoom);
      // function zoomed(event) {
      //   chartArea.attr("transform", event.transform);
      //   k = event.transform.k
      // }

      // var simulation = d3.forceSimulation()
      //   .nodes(data)
      //   .force("collision", d3.forceCollide().radius(d => assetScale(d['Asset']) + 3).strength(0.5))
      //   .force("center", d3.forceCenter(width / 2, height / 2))
      //   .force("charge", d3.forceManyBody().strength(0.5))
      //   .on("tick", render);

      function render() {
        var clicked;
        let circles = chartArea.selectAll("circle.node")
          .data(data)
          .join(
            enter => enter.append("circle")
              .attr("class", "node")
              .attr("r", d => assetScale(d['Asset']))
              .attr("cx", d => d.x)
              .attr("cy", d => d.y)
              .attr("fill", d => colorScale(d['Asset']))
              .on("click", function (d) {
                let node = d3.select(this)
                let selectedData = node.datum();
                var selectedCircle = node.node().getBBox();
                console.log(selectedCircle)
                if (clicked == this) {
                  node.transition().duration(650).attr("fill", d => colorScale(d['Asset']))
                    .attr("r", d => assetScale(d['Asset']));
                  chartArea.selectAll("text").raise();
                  clicked = null;
                  d3.select(".info").remove();
                } else {
                  chartArea.selectAll("text").raise();
                  pastNode = d3.select(clicked)
                  pastNode.transition().duration(650).attr("fill", d => colorScale(d['Asset']))
                    .attr("r", d => assetScale(d['Asset']));
                  node.transition().duration(650).attr("fill", "red")
                    .attr("r", function (d) {
                      x = assetScale(d["Asset"]);
                      if (x > 50) {
                        return x + 30;
                      } else if (x < 51 && x > 20) {
                        return 90;
                      } else {
                        return 100;
                      }
                    });
                  clicked = this;
                  node.raise();
                  d3.select(".info").remove();
                  chartArea.append("text")
                    .data(data)
                    .attr("class", "info")
                    .attr('x', selectedCircle.x + selectedCircle.width / 2)
                    .attr('y', selectedCircle.y + selectedCircle.width / 4)
                    .style("font-size", "12px")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "black")
                    .style('pointer-events', "none")
                    .text(d => {
                      return selectedData['Bank'] + "\n" + "Closing: " + selectedData["Closing Date"]
                        + "\n" + "Assets: " + selectedData['Approx. Asset (Millions)'].split('.')[0] + "\n" + selectedData["City"] + ", " +
                        selectedData["State"];
                    })
                    .call(wrap, 80);
                }
              })
            // .call(d3.drag().on("start", dragstart)
            //   .on("drag", dragging)
            //   .on("end", dragend))
          )
          .transition()
          .duration(1250)
          .attr('opacity', 1)

        let circleText = chartArea.selectAll("text.label")
          .data(data)
          .join("text")
          .attr("class", "label")
          .style("text-anchor", "middle")
          .style("text-align", "center")
          .style("fill", "white")
          .style("pointer-events", "none")
          .attr("x", d => d.x)
          .attr("y", d => {
            if (assetScale(d['Asset']) > 30) {
              return d.y - 5;
            } else if (assetScale(d['Asset']) > 15) {
              return d.y + 3;
            }
          })
          .attr("width", d => assetScale(d['Asset']))
          .style("overflow-y", "auto")
          .style("font-size", "10px")
          .text(d => {
            if (assetScale(d['Asset']) > 30) {
              return d['Bank'] + "\n" + d['Approx. Asset (Millions)'].split('.')[0];
            } else if (assetScale(d['Asset']) > 15) {
              return d['Approx. Asset (Millions)'].split('.')[0];
            } else {
              return "";
            }
          })
          .call(wrap, 60);
      }
      render();

      // function dragstart(event, d) {
      //   if (!event.active) {
      //     simulation.alphaTarget(0.08).restart();
      //   }
      //   d.fx = event.x;
      //   d.fy = event.y;
      // }
      // function dragging(event, d) {
      //   d.fx = event.x;
      //   d.fy = event.y;
      // }
      // function dragend(event, d) {
      //   if (!event.active) {
      //     simulation.alpha(0.5)
      //       .alphaTarget(0.3)
      //       .restart();
      //     simulation.force("collision").initialize(data);
      //   }
      //   d.fx = null;
      //   d.fy = null;
      // }
    }

    drawNetworkDiagram(dataFilter0);

    d3.select("#button").on("click", function (event, d) {
      console.log(JSON.stringify(dataFilter0));
      var minAsset = document.getElementById('minAsset').value || null;
      var maxAsset = document.getElementById('maxAsset').value || null;

      function filterByAsset(obj) {
        if (minAsset <= obj["Asset"] && obj["Asset"] <= maxAsset) {
          return true
        } else {
          return false
        }
      }

      var newData = data.filter(filterByAsset);
      console.log(newData)
      drawNetworkDiagram(newData);

    });

  }
  requestData();



</script>

</html>