<html>

<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="drawLegend.js"></script>
</head>

<body>
  <div>
    <svg id="priceSvg" width=400 height=350></svg>
    <svg id="network" width="900" height="800"></svg>
    <svg id="legend" width="500" height="50"></svg>
    <div class="range">
      <input type="text" id="minAsset" name="minAsset" placeholder="Min Asset">
      <input type="text" id="maxAsset" name="maxAsset" placeholder="Max Asset">
    </div>
    <button id="button">button</button>
  </div>

</body>

<script>
  const svg = d3.select("svg#network");
  const height = svg.attr("height");
  const width = svg.attr("width");

  let chartArea = svg.append("g");

  const requestData = async () => {
    const data = await d3.csv("datasets/bfb-data.csv", d3.autoType);
    const dataFilter0 = await d3.json("datasets/total.json", d3.autoType);

    data.forEach(d => {
      // convert a currency string to a double 
      d["Asset"] = parseFloat(d["Approx. Asset (Millions)"].replace(/[$,]+/g, ""));
      d["Deposit"] = parseFloat(d["Approx. Deposit (Millions)"].replace(/[$,]+/g, ""));

      // split bank name, city, and state 
      const arr = d["Bank Name, City, State"].split(', ');
      d["Bank"] = arr[0];
      d["City"] = arr[1];
      d["State"] = arr[2];
    });

    // sort data by descending Asset
    function compare(a, b) {
      if (a.Asset > b.Asset) {
        return -1;
      }
      if (a.Asset < b.Asset) {
        return 1;
      }
      return 0;
    }
    data.sort(compare);
    console.log("data after processing", data);

    // External code for wrapping a text in d3
    // Citation: https://stackoverflow.com/questions/24784302/wrapping-text-in-d3 
    function wrap(text, width) {
      text.each(function () {
        var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          x = text.attr("x"),
          y = text.attr("y"),
          dy = 0, //parseFloat(text.attr("dy")),
          tspan = text.text(null)
            .append("tspan")
            .attr("x", x)
            .attr("y", y)
            .attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan")
              .attr("x", x)
              .attr("y", y)
              .attr("dy", ++lineNumber * lineHeight + dy + "em")
              .text(word);
          }
        }
      });
    }

    function drawNetworkDiagram(data) {
      let assetExtent = d3.extent(data, d => d['Asset']);
      let assetScale = d3.scaleSqrt().domain(assetExtent).range([3, 130]);
      const colorScale = d3.scaleLog().domain(assetExtent).interpolate(d => d3.interpolateYlGn);

      // Instructor provided code
      // Citation: https://github.com/jeffrz/info3300-fa2022/blob/main/notes/22.10.03.notes.htm
      drawLegend("svg#legend", colorScale);

      // Initial drawing for zoom
      // let circles = chartArea.selectAll("circle.node")
      //   .data(data)
      //   .join(
      //     enter => enter.append("circle")
      //       .attr("class", "node")
      //       .attr("r", d => assetScale(d['Asset']))
      //       .attr("cx", d => d.x)
      //       .attr("cy", d => d.y)
      //       .attr("fill", d => colorScale(d['Asset']))
      //     // .call(d3.drag().on("start", dragstart)
      //     //   .on("drag", dragging)
      //     //   .on("end", dragend))
      //   )
      //   .transition()
      //   .duration(1250)
      //   .attr('opacity', 1)
      // var k = 1;
      // //zooming
      // var zoom = d3.zoom().scaleExtent([1, 10]).on("zoom", zoomed)
      // svg.call(zoom);
      // function zoomed(event) {
      //   chartArea.attr("transform", event.transform);
      //   k = event.transform.k
      // }

      // Simulation for network diagram
      // var simulation = d3.forceSimulation()
      //   .nodes(data)
      //   .force("collision", d3.forceCollide().radius(d => assetScale(d['Asset']) + 3).strength(0.5))
      //   .force("center", d3.forceCenter(width / 2, height / 2))
      //   .force("charge", d3.forceManyBody().strength(0.5))
      //   .on("tick", render);

      function render() {
        var clicked = null;
        let circles = chartArea.selectAll("circle.node")
          .data(data)
          .join(
            enter => enter.append("circle")
              .attr("class", "node")
              .attr("r", d => assetScale(d['Asset']))
              .attr("cx", d => d.x)
              .attr("cy", d => d.y)
              .attr("fill", d => colorScale(d['Asset']))
              .on("click", function (d) {
                let node = d3.select(this)
                let selectedData = node.datum();
                var selectedCircle = node.node().getBBox();
                console.log(selectedCircle)
                if (clicked == this) {
                  node.transition().duration(650).attr("fill", d => colorScale(d['Asset']))
                    .attr("r", d => assetScale(d['Asset']))
                    .style("stroke", "none");
                  let circleText = chartArea.append("text")
                    .attr("class", "extra")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style("pointer-events", "none")
                    .attr("x", d => selectedCircle.x + selectedCircle.width / 2)
                    .attr("y", d => {
                      if (assetScale(selectedData['Asset']) > 30) {
                        return selectedCircle.y + selectedCircle.width / 2 - 5;
                      } else if (assetScale(selectedData['Asset']) > 15) {
                        return selectedCircle.y + selectedCircle.width / 2 + 3;
                      }
                    })
                    .attr("width", d => assetScale(selectedData['Asset']))
                    .style("overflow-y", "auto")
                    .style("font-size", "10px")
                    .text(d => {
                      if (assetScale(selectedData['Asset']) > 30) {
                        return selectedData['Bank'] + "\n" + selectedData['Approx. Asset (Millions)'].split('.')[0];
                      } else if (assetScale(selectedData['Asset']) > 15) {
                        return selectedData['Approx. Asset (Millions)'].split('.')[0];
                      } else {
                        return "";
                      }
                    })
                    .call(wrap, 60);
                  clicked = null;
                  d3.selectAll(".info").remove();
                } else {
                  let pastNode;
                  if (clicked == null) {
                    pastNode = d3.select(this)
                  } else {
                    pastNode = d3.select(clicked)
                  }
                  pastNode.transition().duration(650).attr("fill", d => colorScale(d['Asset']))
                    .attr("r", d => assetScale(d['Asset']))
                    .style("stroke", "none");
                  let pastData = pastNode.datum()
                  let pastCircle = pastNode.node().getBBox()
                  node.transition().duration(650).style("stroke", "white")
                    .style("stroke-width", "5px")
                    .attr("r", function (d) {
                      x = assetScale(d["Asset"]);
                      if (x > 50) {
                        return x + 30;
                      } else if (x < 51 && x > 20) {
                        return 140;
                      } else {
                        return 145;
                      }
                    });
                  let circleText = chartArea.append("text")
                    .attr("class", "extra")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style("pointer-events", "none")
                    .attr("x", d => pastCircle.x + pastCircle.width / 2)
                    .attr("y", d => {
                      if (assetScale(pastData['Asset']) > 30) {
                        return pastCircle.y + pastCircle.width / 2 - 5;
                      } else if (assetScale(pastData['Asset']) > 15) {
                        return pastCircle.y + pastCircle.width / 2 + 3;
                      }
                    })
                    .attr("width", d => assetScale(pastData['Asset']))
                    .style("overflow-y", "auto")
                    .style("font-size", "10px")
                    .text(d => {
                      if (assetScale(pastData['Asset']) > 30) {
                        return pastData['Bank'] + "\n" + pastData['Approx. Asset (Millions)'].split('.')[0];
                      } else if (assetScale(pastData['Asset']) > 15) {
                        return pastData['Approx. Asset (Millions)'].split('.')[0];
                      } else {
                        return "";
                      }
                    })
                    .call(wrap, 60);
                  clicked = this;
                  node.raise();
                  d3.selectAll(".info").remove();
                  chartArea.append("text")
                    .data(data)
                    .attr("class", "info")
                    .attr('x', selectedCircle.x + selectedCircle.width / 2)
                    .attr('y', selectedCircle.y + (selectedCircle.height - 30) / 2)
                    .transition().duration(650)
                    .style("font-size", "15px")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style('pointer-events', "none")
                    .style("font-weight", "bold")
                    .text(d => {
                      return selectedData['Bank'];
                    })
                    .call(wrap, 1000);
                  chartArea.append("text")
                    .data(data)
                    .attr("class", "info")
                    .attr('x', selectedCircle.x + selectedCircle.width / 2)
                    .attr('y', selectedCircle.y + (selectedCircle.height) / 2)
                    .transition().duration(650)
                    .style("font-size", "13px")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style('pointer-events', "none")
                    .text(d => {
                      return "Closing Date: " + selectedData["Closing Date"];
                    })
                    .call(wrap, 1000);
                  chartArea.append("text")
                    .data(data)
                    .attr("class", "info")
                    .attr('x', selectedCircle.x + selectedCircle.width / 2)
                    .attr('y', selectedCircle.y + (selectedCircle.height + 30) / 2)
                    .transition().duration(650)
                    .style("font-size", "13px")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style('pointer-events', "none")
                    .text(d => {
                      return "Assets: " + selectedData['Approx. Asset (Millions)'].split('.')[0];
                    })
                    .call(wrap, 1000);
                  chartArea.append("text")
                    .data(data)
                    .attr("class", "info")
                    .attr('x', selectedCircle.x + selectedCircle.width / 2)
                    .attr('y', selectedCircle.y + (selectedCircle.height + 60) / 2)
                    .transition().duration(650)
                    .style("font-size", "13px")
                    .style("text-anchor", "middle")
                    .style("text-align", "center")
                    .style("fill", "white")
                    .style('pointer-events', "none")
                    .text(d => {
                      return selectedData["City"] + ", " + selectedData["State"];
                    })
                    .call(wrap, 1000);
                }
              })
            // Enable drag and drop
            // .call(d3.drag().on("start", dragstart)
            //   .on("drag", dragging)
            //   .on("end", dragend))
          )
          .transition()
          .duration(1250)
          .attr('opacity', 1)

        let circleText = chartArea.selectAll("text.label")
          .data(data)
          .join("text")
          .attr("class", "label")
          .style("text-anchor", "middle")
          .style("text-align", "center")
          .style("fill", "white")
          .style("pointer-events", "none")
          .attr("x", d => d.x)
          .attr("y", d => {
            if (assetScale(d['Asset']) > 30) {
              return d.y - 5;
            } else if (assetScale(d['Asset']) > 15) {
              return d.y + 3;
            }
          })
          .attr("width", d => assetScale(d['Asset']))
          .style("overflow-y", "auto")
          .style("font-size", "10px")
          .text(d => {
            if (assetScale(d['Asset']) > 30) {
              return d['Bank'] + "\n" + d['Approx. Asset (Millions)'].split('.')[0];
            } else if (assetScale(d['Asset']) > 15) {
              return d['Approx. Asset (Millions)'].split('.')[0];
            } else {
              return "";
            }
          })
          .call(wrap, 60);
      }
      render();

      // function dragstart(event, d) {
      //   if (!event.active) {
      //     simulation.alphaTarget(0.08).restart();
      //   }
      //   d.fx = event.x;
      //   d.fy = event.y;
      // }
      // function dragging(event, d) {
      //   d.fx = event.x;
      //   d.fy = event.y;
      // }
      // function dragend(event, d) {
      //   if (!event.active) {
      //     simulation.alpha(0.5)
      //       .alphaTarget(0.3)
      //       .restart();
      //     simulation.force("collision").initialize(data);
      //   }
      //   d.fx = null;
      //   d.fy = null;
      // }
    }

    drawNetworkDiagram(dataFilter0);

    // ** price bar chart ** 

    // 1. set up data 
    asset = [];
    assetDict = {};

    data.forEach(d => {
      asset.push(d["Asset"])
    });

    console.log(asset); //extent 4.9 307000

    // 2. calculate the batch 
    const rangeStart = 4.9;
    const rangeEnd = 1000;
    const batchSize = (rangeEnd - rangeStart) / 3;

    for (let i = 0; i < 3; i++) {
      const batchStart = rangeStart + (i * batchSize);
      const batchEnd = batchStart + batchSize;
      console.log(`Batch ${i + 1}: ${batchStart.toFixed(1)} - ${batchEnd.toFixed(1)}`);
    }

    // 3. make the dictionary of counts for the price: tick: 6
    assetDict["4.9M"] = 0, assetDict["336M"] = 0, assetDict["668M"] = 0;
    assetDict["1B"] = 0;
    // assetDict["10000.0"] = 0;
    assetDict["10B"] = 0;

    for (let i = 0; i < asset.length; i++) {
      if (asset[i] > 100000) {
        assetDict["10B"] += 1
      }
      // else if (asset[i] > 10000) {
      //   assetDict["10000.0"] += 1
      // } 
      else if (asset[i] > 1000) {
        assetDict["1B"] += 1
      } else if (asset[i] > 668.3) {
        assetDict["668M"] += 1
      } else if (asset[i] > 336.6) {
        assetDict["336M"] += 1
      } else if (asset[i] > 4.9) {
        assetDict["4.9M"] += 1
      }
    }

    console.log(assetDict);

    // 4. set up the svg 
    var svg2 = d3.select("#priceSvg"),
      margin2 = { top: 30, right: 0, bottom: 30, left: 80 },
      width2 = +svg.attr("width") - margin2.left - margin2.right,
      height2 = +svg.attr("height") - margin2.top - margin2.bottom

    g = svg2.append("g").attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    //  Define the scales for the x and y axes
    let xScale = d3.scaleBand()
      .domain(Object.keys(assetDict))
      .range([margin2.left, 400]) //0, width
      .padding(0.2);

    let yScale = d3.scaleLinear()
      .domain([0, d3.max(Object.values(assetDict))])
      .range([300 - margin2.top - margin2.bottom, 0]); //height, 0

    // Create the bars
    svg2.selectAll('rect')
      .data(Object.entries(assetDict))
      .enter()
      .append('rect')
      .attr('x', (d) => xScale(d[0]))
      .attr('y', (d) => margin2.top + yScale(d[1]))
      .attr('width', xScale.bandwidth())
      .attr('height', (d) => 300 - margin2.top - margin2.bottom - yScale(d[1]))
      .attr('fill', 'steelblue');

    // x and y axis labels and titles
    svg2.append('g')
      .attr('transform', 'translate(0, 270)')
      .call(d3.axisBottom(xScale)
        .tickFormat(function (d) {
          return "$" + d;
        }));

    svg2.append('g')
      .attr("transform", `translate(${margin2.left}, ${margin2.top})`)
      .call(d3.axisLeft(yScale));

    //axis label
    svg2.append("text")
      .attr("x", (200 - margin))
      .attr("y", 15)
      .attr("text-anchor", "middle")
      .style("font-size", "18px")
      .style("font-weight", "bold")
      .style("fill", "black")
      .text("Number of Banks by Asset (Millions)");

    svg2.append('text')
      .attr("transform", "translate(" + (width / 2 - margin2.left) + " ," + (320) + ")") //320=y 
      // .attr('x', width2 / 2 + 10)
      // .attr('y', height2 - 10)
      .attr('text-anchor', 'middle')
      .style("font-size", "14px")
      .text('Assets');

    svg2.append("text")
      .attr("text-anchor", "middle")
      .attr("x", -height / 2 + margin2.top + margin2.bottom + 100)
      .attr("y", 30) // distance to the graph
      .attr("transform", "rotate(-90)")
      .style("font-size", "14px")
      .text("Number of Banks");


    let labels = svg2.selectAll('.label')
      .data(Object.entries(assetDict))
      .enter()
      .append('text')
      .attr('class', 'label')
      .attr('x', (d) => xScale(d[0]) + xScale.bandwidth() / 2)
      .attr('y', (d) => margin2.top + yScale(d[1]) - 5) // Adjust y position
      .text((d) => d[1])
      .style("font-size", "12px")
      .style('text-anchor', 'middle')
      .style('visibility', 'visible');



    svg2.selectAll('rect')

      .on('mouseover', function (d) {

        // Show label
        d3.select(this)
          .style('opacity', 0.7);

        // labels
        // // labels.filter(  ((l) => l[0]) ===  ( (d) => d[0] )
        //   .style('visibility', 'visible');
      })

      .on('mouseout', function () {
        // Hide label
        d3.select(this)
          .style('opacity', 1);

        // labels.style('visibility', 'hidden');
      });

    // Button to export JSON file
    // d3.select("#button").on("click", function (event, d) {
    //   console.log(JSON.stringify(dataFilter0));
    // });

  }
  requestData();



</script>

</html>